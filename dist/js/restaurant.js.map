{"version":3,"sources":["dbhelper.js","restaurant_info.js"],"names":["dbPromise","idb","open","upgradeDb","oldVersion","createObjectStore","keypath","transaction","objectStore","createIndex","DBHelper","DATABASE_URL","[object Object]","callback","fetch","then","response","json","restaurants","forEach","restaurant","async","store","db","hasOwnProperty","offlineUpdate","get","id","console","log","add","error","status","statusText","catch","getAll","reviewURL","reviews","review","index","parseInt","stashedReviews","fetchRestaurants","find","r","cuisine","results","filter","cuisine_type","neighborhood","neighborhoods","map","v","i","uniqueNeighborhoods","indexOf","cuisines","uniqueCuisines","photograph","marker","L","latlng","lat","lng","title","name","alt","url","urlForRestaurant","addTo","newMap","method","tx","currStore","is_favorite","put","complete","button","on","querySelector","off","classList","contains","favStatus","toggle","value","openCursor","cycleItems","req","continue","cycleReviews","cursor","body","JSON","stringify","document","addEventListener","event","navigator","onLine","updateServer","initMap","fetchRestaurantFromURL","self","center","zoom","scrollWheelZoom","tileLayer","mapboxToken","maxZoom","attribution","fillBreadcrumb","mapMarkerForRestaurant","getParameterByName","fetchRestaurantById","fillRestaurantHTML","fetchReviewsById","fillReviewsHTML","getElementById","innerHTML","address","image","className","src","imageUrlForRestaurant","setAttribute","favOn","createElement","favOff","favButton","append","e","preventDefault","toggleFav","operating_hours","fillRestaurantHoursHTML","operatingHours","hours","key","row","day","appendChild","time","container","Object","keys","length","noReviews","ul","createReviewHTML","formHolder","formFunction","restaurant_id","li","rating","comments","rest_id","reviewContainer","formTitle","reviewForm","nameDiv","nameLabel","htmlFor","nameInput","type","rateDiv","rateLabel","rateInput","commentDiv","commentLabel","commentInput","placeholder","reviewSubmit","newReview","formDiv","data","user_name","user_rating","user_review","res","stashReview","updateFormDiv","window","location","href","breadcrumb","replace","RegExp","exec","decodeURIComponent"],"mappings":"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","file":"restaurant.js","sourcesContent":["/**\r\n * Common database helper functions.\r\n */\r\n\r\n// First - open our db, or initialize if it's the first time\r\nconst dbPromise = idb.open('restaurantReviewSite', 7, function (upgradeDb) {\r\n  switch (upgradeDb.oldVersion) {\r\n    case 0:\r\n    case 1:\r\n      upgradeDb.createObjectStore('storeInfo', {\r\n        keypath: 'id'\r\n      })\r\n    case 2:\r\n      upgradeDb.createObjectStore('reviews', {\r\n        keypath: 'id'\r\n      })\r\n    case 3:\r\n      var newIndex = upgradeDb.transaction.objectStore('reviews');\r\n      newIndex.createIndex('rest_ID', 'restaurant_id');\r\n  };\r\n});\r\n\r\nclass DBHelper {\r\n\r\n  /**\r\n   * Database URL.\r\n   * Change this to restaurants.json file location on your server.\r\n   */\r\n  static get DATABASE_URL() {\r\n    const port = 1337; // Change this to your server port\r\n    return `http://localhost:${port}/`;\r\n  }\r\n\r\n  /**\r\n   * Fetch all restaurants.\r\n   */\r\n  static fetchRestaurants(callback) {\r\n    // First - try to fetch the data from the server\r\n    fetch(`${DBHelper.DATABASE_URL}restaurants`)\r\n      .then(response => response.json()) // parse the server response\r\n      .then(function (response) {\r\n        if (response) { // if we got a response, set the restaurants value to that and add to idb if not there\r\n          const restaurants = response;\r\n          restaurants.forEach(restaurant => {\r\n            dbPromise.then(async db => { // start a separate transaction for each restaurant, to see if it's in db\r\n              const tx = db.transaction('storeInfo', 'readwrite');\r\n              const store = tx.objectStore('storeInfo');\r\n\r\n              if (!restaurant.hasOwnProperty('offlineUpdate')) {\r\n                restaurant.offlineUpdate = false;\r\n              }\r\n\r\n              // try to get restaurant by id - if it's there, just say it's there - if not, add to db\r\n              const request = await store.get(restaurant.id);\r\n              if (!request) {\r\n                console.log('store is not in db, adding now');\r\n                store.add(restaurant, restaurant.id);\r\n              }\r\n            });\r\n          });\r\n          callback(null, restaurants);\r\n        } else { // otherwise, there's no data and an error is thrown - data doesn't exist at all, even if online\r\n          const error = (`Request failed: ${response.status} - ${response.statusText}`);\r\n          callback(error, null);\r\n        }\r\n      })\r\n      .catch(function () { // then, if the fetch fails, we call our db and check there\r\n        console.log(`Sorry, your internet doesn't seem to be working. Pulling cached data for you now!`);\r\n\r\n        dbPromise.then(function (db) {\r\n          const tx = db.transaction('storeInfo', 'readwrite');\r\n          const store = tx.objectStore('storeInfo');\r\n          return store.getAll();\r\n        })\r\n          .then(function (response) {\r\n            const restaurants = response;\r\n            callback(null, restaurants);\r\n          })\r\n      });\r\n  }\r\n\r\n  static fetchReviewsById(id, callback) {\r\n    // First - try to fetch the data from the server\r\n    console.log('inside fetchReviewsById');\r\n\r\n    const reviewURL = `${DBHelper.DATABASE_URL}reviews/?restaurant_id=${id}`;\r\n    fetch(reviewURL)\r\n      .then(response => response.json()) // parse the server response\r\n      .then(function (response) {\r\n        if (response) {\r\n          console.log('fetch worked - dealing with response now');\r\n          const reviews = response;\r\n          reviews.forEach(review => {\r\n            dbPromise.then(async db => {\r\n              const tx = db.transaction('reviews', 'readwrite');\r\n              const store = tx.objectStore('reviews');\r\n\r\n              if (!review.hasOwnProperty('offlineUpdate')) {\r\n                review.offlineUpdate = false;\r\n              }\r\n\r\n              const request = await store.get(review.id);\r\n              if (!request) {\r\n                console.log('new review found! adding to cache');\r\n                store.add(review, review.id);\r\n              }\r\n            });\r\n          });\r\n          callback(null, reviews);\r\n        } else { // otherwise, there's no data and an error is thrown - data doesn't exist at all, even if online\r\n          console.log('fetch worked, but there was not any data');\r\n          const error = (`Request failed: ${response.status} - ${response.statusText}`);\r\n          callback(error, null);\r\n        }\r\n      })\r\n      .catch(function () { // then, if the fetch fails, we call our db and check there\r\n        console.log(`inside the catch function of fetchReviewsById`);\r\n        dbPromise.then(function (db) {\r\n          const tx = db.transaction('reviews', 'readwrite');\r\n          const store = tx.objectStore('reviews');\r\n          const restIdIndex = store.index('rest_ID');\r\n          const temp = restIdIndex.getAll(parseInt(id, 10));\r\n          return temp;\r\n        })\r\n          .then(function (stashedReviews) {\r\n            const reviews = stashedReviews;\r\n            callback(null, reviews);\r\n          })\r\n      });\r\n  }\r\n\r\n  /**\r\n   * Fetch a restaurant by its ID.\r\n   */\r\n  static fetchRestaurantById(id, callback) {\r\n    // fetch all restaurants with proper error handling.\r\n    DBHelper.fetchRestaurants((error, restaurants) => {\r\n      if (error) {\r\n        callback(error, null);\r\n      } else {\r\n        const restaurant = restaurants.find(r => r.id == id);\r\n        if (restaurant) { // Got the restaurant\r\n          callback(null, restaurant);\r\n        } else { // Restaurant does not exist in the database\r\n          callback('Restaurant does not exist', null);\r\n        }\r\n      }\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Fetch restaurants by a cuisine type with proper error handling.\r\n   */\r\n  static fetchRestaurantByCuisine(cuisine, callback) {\r\n    // Fetch all restaurants  with proper error handling\r\n    DBHelper.fetchRestaurants((error, restaurants) => {\r\n      if (error) {\r\n        callback(error, null);\r\n      } else {\r\n        // Filter restaurants to have only given cuisine type\r\n        const results = restaurants.filter(r => r.cuisine_type == cuisine);\r\n        callback(null, results);\r\n      }\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Fetch restaurants by a neighborhood with proper error handling.\r\n   */\r\n  static fetchRestaurantByNeighborhood(neighborhood, callback) {\r\n    // Fetch all restaurants\r\n    DBHelper.fetchRestaurants((error, restaurants) => {\r\n      if (error) {\r\n        callback(error, null);\r\n      } else {\r\n        // Filter restaurants to have only given neighborhood\r\n        const results = restaurants.filter(r => r.neighborhood == neighborhood);\r\n        callback(null, results);\r\n      }\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Fetch restaurants by a cuisine and a neighborhood with proper error handling.\r\n   */\r\n  static fetchRestaurantByCuisineAndNeighborhood(cuisine, neighborhood, callback) {\r\n    // Fetch all restaurants\r\n    DBHelper.fetchRestaurants((error, restaurants) => {\r\n      if (error) {\r\n        callback(error, null);\r\n      } else {\r\n        let results = restaurants\r\n        if (cuisine != 'all') { // filter by cuisine\r\n          results = results.filter(r => r.cuisine_type == cuisine);\r\n        }\r\n        if (neighborhood != 'all') { // filter by neighborhood\r\n          results = results.filter(r => r.neighborhood == neighborhood);\r\n        }\r\n        callback(null, results);\r\n      }\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Fetch all neighborhoods with proper error handling.\r\n   */\r\n  static fetchNeighborhoods(callback) {\r\n    // Fetch all restaurants\r\n    DBHelper.fetchRestaurants((error, restaurants) => {\r\n      if (error) {\r\n        callback(error, null);\r\n      } else {\r\n        // Get all neighborhoods from all restaurants\r\n        const neighborhoods = restaurants.map((v, i) => restaurants[i].neighborhood)\r\n        // Remove duplicates from neighborhoods\r\n        const uniqueNeighborhoods = neighborhoods.filter((v, i) => neighborhoods.indexOf(v) == i)\r\n        callback(null, uniqueNeighborhoods);\r\n      }\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Fetch all cuisines with proper error handling.\r\n   */\r\n  static fetchCuisines(callback) {\r\n    // Fetch all restaurants\r\n    DBHelper.fetchRestaurants((error, restaurants) => {\r\n      if (error) {\r\n        callback(error, null);\r\n      } else {\r\n        // Get all cuisines from all restaurants\r\n        const cuisines = restaurants.map((v, i) => restaurants[i].cuisine_type)\r\n        // Remove duplicates from cuisines\r\n        const uniqueCuisines = cuisines.filter((v, i) => cuisines.indexOf(v) == i)\r\n        callback(null, uniqueCuisines);\r\n      }\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Restaurant page URL.\r\n   */\r\n  static urlForRestaurant(restaurant) {\r\n    return (`./restaurant.html?id=${restaurant.id}`);\r\n  }\r\n\r\n  /**\r\n   * Restaurant image URL.\r\n   */\r\n  static imageUrlForRestaurant(restaurant) {\r\n    return (`./img/optimized/${restaurant.photograph}-optimized.jpg`);\r\n  }\r\n\r\n  /**\r\n   * Map marker for a restaurant.\r\n   */\r\n  static mapMarkerForRestaurant(restaurant, map) {\r\n    // https://leafletjs.com/reference-1.3.0.html#marker  \r\n    const marker = new L.marker([restaurant.latlng.lat, restaurant.latlng.lng],\r\n      {\r\n        title: restaurant.name,\r\n        alt: restaurant.name,\r\n        url: DBHelper.urlForRestaurant(restaurant)\r\n      })\r\n    marker.addTo(newMap);\r\n    return marker;\r\n  }\r\n\r\n  // Toggle favorite status\r\n  static favStatus(status, id) {\r\n    fetch(`http://localhost:1337/restaurants/${id}/?is_favorite=${status}`, {\r\n      method: 'PUT'\r\n    })\r\n      .then(() => {\r\n        dbPromise.then(async db => {\r\n          const tx = db.transaction('storeInfo', 'readwrite');\r\n          const store = tx.objectStore('storeInfo');\r\n\r\n          const req = await store.get(id);\r\n          const currStore = req;\r\n          currStore.is_favorite = status;\r\n\r\n          store.put(currStore, id);\r\n          console.log('favorite status is marked!');\r\n          return tx.complete;\r\n        })\r\n      })\r\n      .catch(() => {\r\n        dbPromise.then(async db => {\r\n          const tx = db.transaction('storeInfo', 'readwrite');\r\n          const store = tx.objectStore('storeInfo');\r\n\r\n          const req = await store.get(id);\r\n          const currStore = req;\r\n          currStore.is_favorite = status;\r\n          currStore.offlineUpdate = true;\r\n\r\n          store.put(currStore, id);\r\n          console.log('favorite status is marked! will be updated on server when reconnected.');\r\n          return tx.complete;\r\n        })\r\n      })\r\n  }\r\n\r\n  static toggleFav(button, id) {\r\n    // function to toggle favorite button\r\n    const on = button.querySelector('.on');\r\n    const off = button.querySelector('.off');\r\n\r\n    if (on.classList.contains('hide')) {\r\n      DBHelper.favStatus('true', id);\r\n      on.classList.toggle('hide');\r\n      off.classList.toggle('hide');\r\n    } else if (off.classList.contains('hide')) {\r\n      DBHelper.favStatus('false', id);\r\n      on.classList.toggle('hide');\r\n      off.classList.toggle('hide');\r\n    }\r\n  }\r\n\r\n  static stashReview(status, review) {\r\n    console.log(`review to stash: ${review.value}`);\r\n    // if user is offline, turn update flag on\r\n    if (status === 'offline') {\r\n      review.offlineUpdate = true;\r\n    }\r\n    dbPromise.then(db => {\r\n      const tx = db.transaction('reviews', 'readwrite');\r\n      const store = tx.objectStore('reviews');\r\n      const addReview = store.add(review);\r\n      return tx.complete;\r\n    });\r\n  }\r\n\r\n  static updateServer() {\r\n\r\n    //first check storeInfo for favorite updates\r\n    dbPromise.then(function (db) {\r\n      const tx = db.transaction('storeInfo', 'readwrite');\r\n      const store = tx.objectStore('storeInfo');\r\n      return store.openCursor();\r\n    })\r\n      .then(function cycleItems(restaurant) {\r\n        if (!restaurant) return;\r\n        // check each store to see if update flag is on\r\n        if (restaurant.value.offlineUpdate) {\r\n          // add the updated favorite status to the server\r\n          fetch(`http://localhost:1337/restaurants/${restaurant.value.id}/?is_favorite=${restaurant.value.is_favorite}`, {\r\n            method: 'PUT'\r\n          })\r\n          // then change the flag and update it on idb\r\n          dbPromise.then(async db => {\r\n            const tx = db.transaction('storeInfo', 'readwrite');\r\n            const store = tx.objectStore('storeInfo');\r\n\r\n            const req = await store.get(restaurant.value.id);\r\n            req.offlineUpdate = false;\r\n            store.put(req, req.id);\r\n          })\r\n        }\r\n        // then, go to the next store and check again\r\n        return restaurant.continue().then(cycleItems);\r\n      })\r\n\r\n    // then check reviews for new ones\r\n    dbPromise.then(function (db) {\r\n      const tx = db.transaction('reviews', 'readwrite');\r\n      const store = tx.objectStore('reviews');\r\n      return store.openCursor();\r\n    })\r\n      .then(function cycleReviews(cursor) {\r\n        if (!cursor) return;\r\n        // again, check current reviews in idb for update flag\r\n        if (cursor.value.offlineUpdate) {\r\n\r\n          // post new review to server\r\n          fetch('http://localhost:1337/reviews/', {\r\n            method: 'POST',\r\n            body: JSON.stringify(review)\r\n          })\r\n\r\n          // then switch update flag off and post to idb\r\n          dbPromise.then(async db => {\r\n            const tx = db.transaction('reviews', 'readwrite');\r\n            const store = tx.objectStore('reviews');\r\n            const req = await store.get(cursor.value.id);\r\n            req.offlineUpdate = false;\r\n            store.put(req, req.id);\r\n          })\r\n        }\r\n        // then go to next review and do it all again\r\n        return cursor.continue().then(cycleReviews);\r\n      })\r\n\r\n    /*\r\n    // check if tempStorage has any items - these will be favorite updates\r\n    dbPromise.then(function (db) {\r\n      const tx = db.transaction('tempStorage', 'readwrite');\r\n      const store = tx.objectStore('tempStorage');\r\n      return store.openCursor();\r\n    })\r\n      .then(function cycleItems(cursor) {\r\n        if (!cursor) return;\r\n\r\n        if (cursor.value.type === 'favorite') {\r\n          // favorite update \r\n          // update server with new status\r\n          fetch(`http://localhost:1337/restaurants/${cursor.value.restaurant_id}/?is_favorite=${cursor.value.is_favorite}`, {\r\n            method: 'PUT'\r\n          })\r\n          // then update storeInfo db with status\r\n          dbPromise.then(async db => {\r\n            const tx = db.transaction('storeInfo', 'readwrite');\r\n            const store = tx.objectStore('storeInfo');\r\n\r\n            const req = await store.get(cursor.value.restaurant_id);\r\n            const currStore = req;\r\n            currStore.is_favorite = cursor.value.is_favorite;\r\n            store.put(currStore, cursor.value.restaurant_id);\r\n          })\r\n        }\r\n\r\n        cursor.delete();\r\n        return cursor.continue().then(cycleItems);\r\n      })\r\n\r\n    // now check tempReviews - this will have offline reviews saved\r\n    dbPromise.then(function (db) {\r\n      const tx = db.transaction('tempReviews', 'readwrite');\r\n      const store = tx.objectStore('tempReviews');\r\n      return store.openCursor();\r\n    })\r\n      .then(function cycleReviews(cursor) {\r\n        if (!cursor) return;\r\n\r\n        if (cursor.value.type === 'review') {\r\n          // add new reviews\r\n          // set up review as requested in server options - will remove type key\r\n          const review = {\r\n            \"restaurant_id\": cursor.value.restaurant_id,\r\n            \"name\": cursor.value.name,\r\n            \"rating\": parseInt(cursor.value.rating, 10),\r\n            \"comments\": cursor.value.comments\r\n          }\r\n          // post to server and add to reviews db\r\n          fetch('http://localhost:1337/reviews/', {\r\n            method: 'POST',\r\n            body: JSON.stringify(review)\r\n          })\r\n          dbPromise.then(async db => {\r\n            const tx = db.transaction('reviews', 'readwrite');\r\n            const store = tx.objectStore('reviews');\r\n            console.log('adding an offline stashed review to the db');\r\n            store.add(review);\r\n          });\r\n        }\r\n      })\r\n      */\r\n  }\r\n\r\n} //end of class\r\n","let restaurant;\r\nlet reviews;\r\nvar newMap;\r\n\r\n/**\r\n * Initialize map as soon as the page is loaded.\r\n */\r\ndocument.addEventListener('DOMContentLoaded', (event) => {  \r\n  if (navigator.onLine) {\r\n    DBHelper.updateServer();\r\n  }\r\n  initMap();\r\n});\r\n\r\n/**\r\n * Initialize leaflet map\r\n */\r\ninitMap = () => {\r\n  fetchRestaurantFromURL((error, restaurant) => {\r\n    if (error) { // Got an error!\r\n      console.error(error);\r\n    } else {      \r\n      self.newMap = L.map('map', {\r\n        center: [restaurant.latlng.lat, restaurant.latlng.lng],\r\n        zoom: 16,\r\n        scrollWheelZoom: false\r\n      });\r\n      L.tileLayer('https://api.tiles.mapbox.com/v4/{id}/{z}/{x}/{y}.jpg70?access_token={mapboxToken}', {\r\n        mapboxToken: 'pk.eyJ1IjoibGluZGFrdDE2IiwiYSI6ImNqaW1sY3Z4bjAxa2EzcHBmaTZ4aTE2dzQifQ.cOXPk5Jme5zrFsUP3KEgLw',\r\n        maxZoom: 18,\r\n        attribution: 'Map data &copy; <a href=\"https://www.openstreetmap.org/\">OpenStreetMap</a> contributors, ' +\r\n          '<a href=\"https://creativecommons.org/licenses/by-sa/2.0/\">CC-BY-SA</a>, ' +\r\n          'Imagery Â© <a href=\"https://www.mapbox.com/\">Mapbox</a>',\r\n        id: 'mapbox.streets'    \r\n      }).addTo(newMap);\r\n      fillBreadcrumb();\r\n      DBHelper.mapMarkerForRestaurant(self.restaurant, self.newMap);\r\n    }\r\n  });\r\n}  \r\n \r\n/**\r\n * Get current restaurant from page URL.\r\n */\r\nfetchRestaurantFromURL = (callback) => {\r\n  if (self.restaurant) { // restaurant already fetched!\r\n    callback(null, self.restaurant)\r\n    return;\r\n  }\r\n  const id = getParameterByName('id');\r\n  if (!id) { // no id found in URL\r\n    error = 'No restaurant id in URL'\r\n    callback(error, null);\r\n  } else {\r\n    DBHelper.fetchRestaurantById(id, (error, restaurant) => {\r\n      self.restaurant = restaurant;\r\n      if (!restaurant) {\r\n        console.error(error);\r\n        return;\r\n      }\r\n      fillRestaurantHTML();\r\n      callback(null, restaurant)\r\n    });\r\n    DBHelper.fetchReviewsById(id, (error, reviews) => {\r\n      self.reviews = reviews;\r\n      if (!reviews) {\r\n        console.error(error);\r\n        console.log('no reviews found from fetch')\r\n        return;\r\n      }\r\n      fillReviewsHTML(reviews);\r\n    });\r\n  }\r\n}\r\n\r\n/**\r\n * Create restaurant HTML and add it to the webpage\r\n */\r\nfillRestaurantHTML = (restaurant = self.restaurant) => {\r\n  const name = document.getElementById('restaurant-name');\r\n  name.innerHTML = restaurant.name;\r\n\r\n  const address = document.getElementById('restaurant-address');\r\n  address.innerHTML = restaurant.address;\r\n\r\n  const image = document.getElementById('restaurant-img');\r\n  image.className = 'restaurant-img'\r\n  image.src = DBHelper.imageUrlForRestaurant(restaurant);\r\n  image.alt = `A photo showcasing the atmosphere of ${restaurant.name}`;\r\n\r\n  const cuisine = document.getElementById('restaurant-cuisine');\r\n  cuisine.innerHTML = restaurant.cuisine_type;\r\n  cuisine.setAttribute('aria-label', `${restaurant.cuisine_type} restaurant`);\r\n\r\n  const favOn = document.createElement('img'); \r\n  favOn.src = `./img/icons/fav_on.svg`;\r\n  favOn.className = 'favorite on';\r\n  favOn.alt = 'Favorite restaurant toggle turned on';\r\n  const favOff = document.createElement('img');\r\n  favOff.src = `./img/icons/fav_off.svg`;\r\n  favOff.className = 'favorite off';\r\n  favOff.alt = 'Favorite restaurant toggle turned off';\r\n   if (restaurant.is_favorite == 'false') {\r\n    favOn.classList.add('hide');\r\n  } else if (restaurant.is_favorite == 'true') {\r\n    favOff.classList.add('hide');\r\n  }\r\n  const favButton = document.getElementById('fav');\r\n  favButton.setAttribute('aria-label', `Toggle this restaurant's favorite status`);\r\n  favButton.append(favOn, favOff);\r\n  \r\n  favButton.addEventListener('click', function(e) {\r\n    e.preventDefault();\r\n    DBHelper.toggleFav(favButton, restaurant.id);\r\n  })\r\n\r\n  // fill operating hours\r\n  if (restaurant.operating_hours) {\r\n    fillRestaurantHoursHTML();\r\n  }\r\n}\r\n\r\n/**\r\n * Create restaurant operating hours HTML table and add it to the webpage.\r\n */\r\nfillRestaurantHoursHTML = (operatingHours = self.restaurant.operating_hours) => {\r\n  const hours = document.getElementById('restaurant-hours');\r\n  for (let key in operatingHours) {\r\n    const row = document.createElement('tr');\r\n\r\n    const day = document.createElement('td');\r\n    day.innerHTML = key;\r\n    row.appendChild(day);\r\n\r\n    const time = document.createElement('td');\r\n    time.innerHTML = operatingHours[key];\r\n    row.appendChild(time);\r\n\r\n    hours.appendChild(row);\r\n  }\r\n}\r\n\r\n/**\r\n * Create all reviews HTML and add them to the webpage.\r\n */\r\nfillReviewsHTML = (reviews = self.reviews) => {\r\n  console.log('inside fillReviewsHTML function');\r\n  const container = document.getElementById('reviews-container');\r\n  const title = document.createElement('h3');\r\n  title.innerHTML = 'Reviews';\r\n  container.appendChild(title);\r\n  container.setAttribute('aria-label', 'Reviews');\r\n\r\n  if (!reviews || Object.keys(reviews).length == 0) {\r\n    const noReviews = document.createElement('p');\r\n    noReviews.innerHTML = 'No reviews yet!';\r\n    container.appendChild(noReviews);\r\n    return;\r\n  }\r\n  const ul = document.getElementById('reviews-list');\r\n  reviews.forEach(review => {\r\n    ul.appendChild(createReviewHTML(review));\r\n  });\r\n  container.appendChild(ul);\r\n\r\n  const formHolder = formFunction(reviews[0].restaurant_id);\r\n  container.appendChild(formHolder);\r\n}\r\n\r\n/**\r\n * Create review HTML and add it to the webpage.\r\n */\r\ncreateReviewHTML = (review) => {\r\n  const li = document.createElement('li');\r\n  const name = document.createElement('p');\r\n  name.innerHTML = review.name;\r\n  li.appendChild(name);\r\n\r\n  const rating = document.createElement('p');\r\n  rating.innerHTML = `Rating: ${review.rating}`;\r\n  li.appendChild(rating);\r\n\r\n  const comments = document.createElement('p');\r\n  comments.innerHTML = review.comments;\r\n  li.appendChild(comments);\r\n\r\n  return li;\r\n}\r\n\r\nformFunction = (rest_id) => {\r\n  const reviewContainer = document.getElementById('addReview');\r\n  const formTitle = document.createElement('h4');\r\n  formTitle.innerHTML = 'Add Your Own Review!';\r\n  reviewContainer.appendChild(formTitle);\r\n\r\n  const reviewForm = document.createElement('form');\r\n  reviewForm.id = 'addReviewForm';\r\n  \r\n  const nameDiv = document.createElement('div');\r\n  nameDiv.className = 'formDivider';\r\n  const nameLabel = document.createElement('label');\r\n  nameLabel.htmlFor = 'name';\r\n  nameLabel.innerHTML = 'Your Name:';\r\n  const nameInput = document.createElement('input');\r\n  nameInput.type = 'text';\r\n  nameInput.name = 'user_name';\r\n  nameInput.id = 'name';\r\n  nameDiv.appendChild(nameLabel);\r\n  nameDiv.appendChild(nameInput);\r\n\r\n  reviewForm.appendChild(nameDiv);\r\n\r\n  const rateDiv = document.createElement('div');\r\n  rateDiv.className = 'formDivider';\r\n  const rateLabel = document.createElement('label');\r\n  rateLabel.htmlFor = 'rating';\r\n  rateLabel.innerHTML = 'Rating: <br> (1 low, 5 high)';\r\n  const rateInput = document.createElement('input');\r\n  rateInput.type = 'number';\r\n  rateInput.name = 'user_rating';\r\n  rateInput.id = 'rating';\r\n  rateDiv.appendChild(rateLabel);\r\n  rateDiv.appendChild(rateInput);\r\n\r\n  reviewForm.appendChild(rateDiv);\r\n\r\n  const commentDiv = document.createElement('div');\r\n  commentDiv.className = 'formDivider';\r\n  const commentLabel = document.createElement('label');\r\n  commentLabel.htmlFor = 'uReview';\r\n  commentLabel.innerHTML = 'Comments:';\r\n  const commentInput = document.createElement('textarea');\r\n  commentInput.name = 'user_review';\r\n  commentInput.id = 'uReview';\r\n  commentInput.placeholder = 'How was this place?';\r\n  commentDiv.appendChild(commentLabel);\r\n  commentDiv.appendChild(commentInput);\r\n\r\n  reviewForm.appendChild(commentDiv);\r\n  \r\n  const reviewSubmit = document.createElement('button');\r\n  reviewSubmit.type = 'submit';\r\n  reviewSubmit.id = 'submitReview';\r\n  reviewSubmit.innerHTML = 'Post Review';\r\n\r\n  reviewForm.appendChild(reviewSubmit);\r\n\r\n  reviewContainer.appendChild(reviewForm);\r\n\r\n  reviewForm.addEventListener('submit', function(event) {\r\n    event.preventDefault();\r\n    newReview(rest_id, reviewContainer, reviewForm);\r\n  })\r\n\r\n  return reviewContainer;\r\n}\r\n\r\nnewReview = (id, formDiv, data) => {\r\n  //build the review, per the server's specifications\r\n  const review = {\r\n    \"restaurant_id\": id,\r\n    \"name\": data.user_name.value,\r\n    \"rating\": parseInt(data.user_rating.value, 10),\r\n    \"comments\": data.user_review.value\r\n  };\r\n  const posturl = 'http://localhost:1337/reviews/';\r\n\r\n  // try to post the review to the server\r\n  fetch(posturl, {\r\n    method: 'POST',\r\n    body: JSON.stringify(review)\r\n  })\r\n  .then(res => res.json())\r\n  .then(\r\n    // if response code is good - success! add new review to main db & reload reviews\r\n    (res) => {\r\n      console.log('Success! Your review has been received. Response: ', res);\r\n      DBHelper.stashReview('online', res);\r\n      updateFormDiv(formDiv);\r\n    })\r\n  // if fetch didn't work, store the new review in the temp db and reload reviews\r\n  .catch(error => {\r\n    console.error('Sorry, fetch failed! Storing review offline. Error code: ', error);\r\n    DBHelper.stashReview('offline', review);  \r\n    updateFormDiv(formDiv);\r\n  })\r\n}\r\n\r\nupdateFormDiv = (formDiv) => {\r\n  formDiv.innerHTML = `\r\n    <p> Thanks for adding your review! Reload the page to see your review live! </p>\r\n    <button class='reloadBtn'><a href=\" ${window.location.href} \"> Reload now? </a></button>\r\n  `\r\n}\r\n\r\n/**\r\n * Add restaurant name to the breadcrumb navigation menu\r\n */\r\nfillBreadcrumb = (restaurant=self.restaurant) => {\r\n  const breadcrumb = document.getElementById('breadcrumb');\r\n  const li = document.createElement('li');\r\n  li.innerHTML = restaurant.name;\r\n  breadcrumb.appendChild(li);\r\n}\r\n\r\n/**\r\n * Get a parameter by name from page URL.\r\n */\r\ngetParameterByName = (name, url) => {\r\n  if (!url)\r\n    url = window.location.href;\r\n  name = name.replace(/[\\[\\]]/g, '\\\\$&');\r\n  const regex = new RegExp(`[?&]${name}(=([^&#]*)|&|#|$)`),\r\n    results = regex.exec(url);\r\n  if (!results)\r\n    return null;\r\n  if (!results[2])\r\n    return '';\r\n  return decodeURIComponent(results[2].replace(/\\+/g, ' '));\r\n}\r\n\r\n"]}