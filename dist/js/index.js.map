{"version":3,"sources":["dbhelper.js","main.js"],"names":["dbPromise","idb","open","upgradeDb","oldVersion","createObjectStore","keypath","transaction","objectStore","createIndex","autoIncrement","DBHelper","DATABASE_URL","[object Object]","callback","fetch","then","response","json","restaurants","forEach","restaurant","async","store","db","hasOwnProperty","offlineUpdate","get","id","console","log","add","error","status","statusText","catch","getAll","reviewURL","reviews","review","index","parseInt","stashedReviews","fetchRestaurants","find","r","cuisine","results","filter","cuisine_type","neighborhood","neighborhoods","map","v","i","uniqueNeighborhoods","indexOf","cuisines","uniqueCuisines","photograph","marker","L","latlng","lat","lng","title","name","alt","url","urlForRestaurant","addTo","newMap","method","tx","currStore","is_favorite","put","complete","button","on","querySelector","off","classList","contains","favStatus","toggle","openCursor","cycleItems","value","continue","cursor","restaurant_id","rating","comments","body","JSON","stringify","markers","document","addEventListener","event","navigator","onLine","updateServer","initMap","fetchNeighborhoods","fetchCuisines","self","fillNeighborhoodsHTML","select","getElementById","option","createElement","innerHTML","append","fillCuisinesHTML","center","zoom","scrollWheelZoom","tileLayer","mapboxToken","maxZoom","attribution","updateRestaurants","cSelect","nSelect","cIndex","selectedIndex","nIndex","fetchRestaurantByCuisineAndNeighborhood","resetRestaurants","fillRestaurantsHTML","remove","ul","createRestaurantHTML","addMarkersToMap","li","image","className","src","imageUrlForRestaurant","fav","setAttribute","favOn","favOff","trigger","e","preventDefault","toggleFav","address","more","href","mapMarkerForRestaurant","window","location","options","push"],"mappings":"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","file":"index.js","sourcesContent":["/**\r\n * Common database helper functions.\r\n */\r\n\r\n// First - open our db, or initialize if it's the first time\r\nconst dbPromise = idb.open('restaurantReviewSite', 6, function (upgradeDb) {\r\n  switch (upgradeDb.oldVersion) {\r\n    case 0:\r\n    case 1:\r\n      upgradeDb.createObjectStore('storeInfo', {\r\n        keypath: 'id'\r\n      })\r\n    case 2:\r\n      upgradeDb.createObjectStore('reviews', {\r\n        keypath: 'id'\r\n      })\r\n    case 3:\r\n      var newIndex = upgradeDb.transaction.objectStore('reviews');\r\n      newIndex.createIndex('rest_ID', 'restaurant_id');\r\n    case 4:\r\n      upgradeDb.createObjectStore('tempStorage', {\r\n        keypath: 'id',\r\n        autoIncrement: true\r\n      })\r\n    case 5:\r\n      var restIndex = upgradeDb.transaction.objectStore('tempStorage');\r\n      restIndex.createIndex('rest_id', 'restaurant_id');\r\n\r\n      upgradeDb.createObjectStore('tempReviews', {\r\n        keypath: 'id'\r\n      })\r\n\r\n      var revIndex = upgradeDb.transaction.objectStore('tempReviews');\r\n      revIndex.createIndex('rest_id', 'restaurant_id');\r\n  };\r\n});\r\n\r\nclass DBHelper {\r\n\r\n  /**\r\n   * Database URL.\r\n   * Change this to restaurants.json file location on your server.\r\n   */\r\n  static get DATABASE_URL() {\r\n    const port = 1337; // Change this to your server port\r\n    return `http://localhost:${port}/`;\r\n  }\r\n\r\n  /**\r\n   * Fetch all restaurants.\r\n   */\r\n  static fetchRestaurants(callback) {\r\n    // First - try to fetch the data from the server\r\n    fetch(`${DBHelper.DATABASE_URL}restaurants`)\r\n      .then(response => response.json()) // parse the server response\r\n      .then(function (response) {\r\n        if (response) { // if we got a response, set the restaurants value to that and add to idb if not there\r\n          const restaurants = response;\r\n          restaurants.forEach(restaurant => {\r\n            dbPromise.then(async db => { // start a separate transaction for each restaurant, to see if it's in db\r\n              const tx = db.transaction('storeInfo', 'readwrite');\r\n              const store = tx.objectStore('storeInfo');\r\n\r\n              if (!restaurant.hasOwnProperty('offlineUpdate')) {\r\n                restaurant.offlineUpdate = false;\r\n              }\r\n\r\n              // try to get restaurant by id - if it's there, just say it's there - if not, add to db\r\n              const request = await store.get(restaurant.id);\r\n              if (!request) {\r\n                console.log('store is not in db, adding now');\r\n                store.add(restaurant, restaurant.id);\r\n              }\r\n            });\r\n          });\r\n          callback(null, restaurants);\r\n        } else { // otherwise, there's no data and an error is thrown - data doesn't exist at all, even if online\r\n          const error = (`Request failed: ${response.status} - ${response.statusText}`);\r\n          callback(error, null);\r\n        }\r\n      })\r\n      .catch(function () { // then, if the fetch fails, we call our db and check there\r\n        console.log(`Sorry, your internet doesn't seem to be working. Pulling cached data for you now!`);\r\n\r\n        dbPromise.then(function (db) {\r\n          const tx = db.transaction('storeInfo', 'readwrite');\r\n          const store = tx.objectStore('storeInfo');\r\n          return store.getAll();\r\n        })\r\n          .then(function (response) {\r\n            const restaurants = response;\r\n            callback(null, restaurants);\r\n          })\r\n      });\r\n  }\r\n\r\n  static fetchReviewsById(id, callback) {\r\n    // First - try to fetch the data from the server\r\n    console.log('inside fetchReviewsById');\r\n\r\n    const reviewURL = `${DBHelper.DATABASE_URL}reviews/?restaurant_id=${id}`;\r\n    fetch(reviewURL)\r\n      .then(response => response.json()) // parse the server response\r\n      .then(function (response) {\r\n        if (response) {\r\n          console.log('fetch worked - dealing with response now');\r\n          const reviews = response;\r\n          reviews.forEach(review => {\r\n            dbPromise.then(async db => {\r\n              const tx = db.transaction('reviews', 'readwrite');\r\n              const store = tx.objectStore('reviews');\r\n\r\n              if (!review.hasOwnProperty('offlineUpdate')) {\r\n                review.offlineUpdate = false;\r\n              }\r\n\r\n              const request = await store.get(review.id);\r\n              if (!request) {\r\n                console.log('new review found! adding to cache');\r\n                store.add(review, review.id);\r\n              }\r\n            });\r\n          });\r\n          callback(null, reviews);\r\n        } else { // otherwise, there's no data and an error is thrown - data doesn't exist at all, even if online\r\n          console.log('fetch worked, but there was not any data');\r\n          const error = (`Request failed: ${response.status} - ${response.statusText}`);\r\n          callback(error, null);\r\n        }\r\n      })\r\n      .catch(function () { // then, if the fetch fails, we call our db and check there\r\n        console.log(`inside the catch function of fetchReviewsById`);\r\n        dbPromise.then(function (db) {\r\n          const tx = db.transaction('reviews', 'readwrite');\r\n          const store = tx.objectStore('reviews');\r\n          const restIdIndex = store.index('rest_ID');\r\n          const temp = restIdIndex.getAll(parseInt(id, 10));\r\n          return temp;\r\n        })\r\n          .then(function (stashedReviews) {\r\n            const reviews = stashedReviews;\r\n            callback(null, reviews);\r\n          })\r\n      });\r\n  }\r\n\r\n  /**\r\n   * Fetch a restaurant by its ID.\r\n   */\r\n  static fetchRestaurantById(id, callback) {\r\n    // fetch all restaurants with proper error handling.\r\n    DBHelper.fetchRestaurants((error, restaurants) => {\r\n      if (error) {\r\n        callback(error, null);\r\n      } else {\r\n        const restaurant = restaurants.find(r => r.id == id);\r\n        if (restaurant) { // Got the restaurant\r\n          callback(null, restaurant);\r\n        } else { // Restaurant does not exist in the database\r\n          callback('Restaurant does not exist', null);\r\n        }\r\n      }\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Fetch restaurants by a cuisine type with proper error handling.\r\n   */\r\n  static fetchRestaurantByCuisine(cuisine, callback) {\r\n    // Fetch all restaurants  with proper error handling\r\n    DBHelper.fetchRestaurants((error, restaurants) => {\r\n      if (error) {\r\n        callback(error, null);\r\n      } else {\r\n        // Filter restaurants to have only given cuisine type\r\n        const results = restaurants.filter(r => r.cuisine_type == cuisine);\r\n        callback(null, results);\r\n      }\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Fetch restaurants by a neighborhood with proper error handling.\r\n   */\r\n  static fetchRestaurantByNeighborhood(neighborhood, callback) {\r\n    // Fetch all restaurants\r\n    DBHelper.fetchRestaurants((error, restaurants) => {\r\n      if (error) {\r\n        callback(error, null);\r\n      } else {\r\n        // Filter restaurants to have only given neighborhood\r\n        const results = restaurants.filter(r => r.neighborhood == neighborhood);\r\n        callback(null, results);\r\n      }\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Fetch restaurants by a cuisine and a neighborhood with proper error handling.\r\n   */\r\n  static fetchRestaurantByCuisineAndNeighborhood(cuisine, neighborhood, callback) {\r\n    // Fetch all restaurants\r\n    DBHelper.fetchRestaurants((error, restaurants) => {\r\n      if (error) {\r\n        callback(error, null);\r\n      } else {\r\n        let results = restaurants\r\n        if (cuisine != 'all') { // filter by cuisine\r\n          results = results.filter(r => r.cuisine_type == cuisine);\r\n        }\r\n        if (neighborhood != 'all') { // filter by neighborhood\r\n          results = results.filter(r => r.neighborhood == neighborhood);\r\n        }\r\n        callback(null, results);\r\n      }\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Fetch all neighborhoods with proper error handling.\r\n   */\r\n  static fetchNeighborhoods(callback) {\r\n    // Fetch all restaurants\r\n    DBHelper.fetchRestaurants((error, restaurants) => {\r\n      if (error) {\r\n        callback(error, null);\r\n      } else {\r\n        // Get all neighborhoods from all restaurants\r\n        const neighborhoods = restaurants.map((v, i) => restaurants[i].neighborhood)\r\n        // Remove duplicates from neighborhoods\r\n        const uniqueNeighborhoods = neighborhoods.filter((v, i) => neighborhoods.indexOf(v) == i)\r\n        callback(null, uniqueNeighborhoods);\r\n      }\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Fetch all cuisines with proper error handling.\r\n   */\r\n  static fetchCuisines(callback) {\r\n    // Fetch all restaurants\r\n    DBHelper.fetchRestaurants((error, restaurants) => {\r\n      if (error) {\r\n        callback(error, null);\r\n      } else {\r\n        // Get all cuisines from all restaurants\r\n        const cuisines = restaurants.map((v, i) => restaurants[i].cuisine_type)\r\n        // Remove duplicates from cuisines\r\n        const uniqueCuisines = cuisines.filter((v, i) => cuisines.indexOf(v) == i)\r\n        callback(null, uniqueCuisines);\r\n      }\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Restaurant page URL.\r\n   */\r\n  static urlForRestaurant(restaurant) {\r\n    return (`./restaurant.html?id=${restaurant.id}`);\r\n  }\r\n\r\n  /**\r\n   * Restaurant image URL.\r\n   */\r\n  static imageUrlForRestaurant(restaurant) {\r\n    return (`./img/optimized/${restaurant.photograph}-optimized.jpg`);\r\n  }\r\n\r\n  /**\r\n   * Map marker for a restaurant.\r\n   */\r\n  static mapMarkerForRestaurant(restaurant, map) {\r\n    // https://leafletjs.com/reference-1.3.0.html#marker  \r\n    const marker = new L.marker([restaurant.latlng.lat, restaurant.latlng.lng],\r\n      {\r\n        title: restaurant.name,\r\n        alt: restaurant.name,\r\n        url: DBHelper.urlForRestaurant(restaurant)\r\n      })\r\n    marker.addTo(newMap);\r\n    return marker;\r\n  }\r\n\r\n  // Toggle favorite status\r\n  static favStatus(status, id) {\r\n    fetch(`http://localhost:1337/restaurants/${id}/?is_favorite=${status}`, {\r\n      method: 'PUT'\r\n    })\r\n      .then(() => {\r\n        dbPromise.then(async db => {\r\n          const tx = db.transaction('storeInfo', 'readwrite');\r\n          const store = tx.objectStore('storeInfo');\r\n\r\n          const req = await store.get(id);\r\n          const currStore = req;\r\n          currStore.is_favorite = status;\r\n\r\n          store.put(currStore, id);\r\n          console.log('favorite status is marked!');\r\n          return tx.complete;\r\n        })\r\n      })\r\n      .catch(() => {\r\n        dbPromise.then(async db => {\r\n          const tx = db.transaction('storeInfo', 'readwrite');\r\n          const store = tx.objectStore('storeInfo');\r\n\r\n          const req = await store.get(id);\r\n          const currStore = req;\r\n          currStore.is_favorite = status;\r\n          currStore.offlineUpdate = true;\r\n\r\n          store.put(currStore, id);\r\n          console.log('favorite status is marked! will be updated on server when reconnected.');\r\n          return tx.complete;\r\n        })\r\n      })\r\n  }\r\n\r\n  static toggleFav(button, id) {\r\n    // function to toggle favorite button\r\n    const on = button.querySelector('.on');\r\n    const off = button.querySelector('.off');\r\n\r\n    if (on.classList.contains('hide')) {\r\n      DBHelper.favStatus('true', id);\r\n      on.classList.toggle('hide');\r\n      off.classList.toggle('hide');\r\n    } else if (off.classList.contains('hide')) {\r\n      DBHelper.favStatus('false', id);\r\n      on.classList.toggle('hide');\r\n      off.classList.toggle('hide');\r\n    }\r\n  }\r\n\r\n  static stashReview(status, review) {\r\n    // if user is online, add review to main db\r\n    if (status === 'online') {\r\n      dbPromise.then(db => {\r\n        const tx = db.transaction('reviews', 'readwrite');\r\n        const store = tx.objectStore('reviews');\r\n        const addReviewToMain = store.add(review, review.id);\r\n        return tx.complete;\r\n      });\r\n    }\r\n    // if user is offline, add review to temp db\r\n    if (status === 'offline') {\r\n      dbPromise.then(db => {\r\n        const tx = db.transaction('reviews', 'readwrite');\r\n        const store = tx.objectStore('reviews');\r\n        review.offlineUpdate = true;\r\n        const addReviewToTemp = store.add(review, review.id);\r\n        return tx.complete;\r\n      });\r\n    }\r\n  }\r\n\r\n  static updateServer() {\r\n\r\n    //first check storeInfo for favorite updates\r\n    dbPromise.then(function (db) {\r\n      const tx = db.transaction('storeInfo', 'readwrite');\r\n      const store = tx.objectStore('storeInfo');\r\n      return store.openCursor();\r\n    })\r\n      .then(function cycleItems(restaurant) {\r\n        if (!restaurant) return;\r\n\r\n        if (restaurant.value.offlineUpdate) {\r\n          restaurant.value.offlineUpdate = false;\r\n          fetch(`http://localhost:1337/restaurants/${restaurant.value.id}/?is_favorite=${restaurant.value.is_favorite}`, {\r\n            method: 'PUT'\r\n          })\r\n        }\r\n        return restaurant.continue().then(cycleItems);\r\n      })\r\n\r\n    // then check reviews for new ones\r\n    dbPromise.then(function (db) {\r\n      const tx = db.transaction('reviews', 'readwrite');\r\n      const store = tx.objectStore('reviews');\r\n      return store.openCursor();\r\n    })\r\n      .then(function cycleReviews(cursor) {\r\n        if (!cursor) return;\r\n\r\n        if (cursor.value.offlineUpdate) {\r\n          // add new reviews\r\n          // set up review as requested in server options - will remove type key\r\n          const review = {\r\n            \"restaurant_id\": cursor.value.restaurant_id,\r\n            \"name\": cursor.value.name,\r\n            \"rating\": parseInt(cursor.value.rating, 10),\r\n            \"comments\": cursor.value.comments,\r\n            \"offlineUpdate\": false\r\n          }\r\n          // post to server and add to reviews db\r\n          fetch('http://localhost:1337/reviews/', {\r\n            method: 'POST',\r\n            body: JSON.stringify(review)\r\n          })\r\n        }\r\n      })\r\n\r\n    /*\r\n    // check if tempStorage has any items - these will be favorite updates\r\n    dbPromise.then(function (db) {\r\n      const tx = db.transaction('tempStorage', 'readwrite');\r\n      const store = tx.objectStore('tempStorage');\r\n      return store.openCursor();\r\n    })\r\n      .then(function cycleItems(cursor) {\r\n        if (!cursor) return;\r\n\r\n        if (cursor.value.type === 'favorite') {\r\n          // favorite update \r\n          // update server with new status\r\n          fetch(`http://localhost:1337/restaurants/${cursor.value.restaurant_id}/?is_favorite=${cursor.value.is_favorite}`, {\r\n            method: 'PUT'\r\n          })\r\n          // then update storeInfo db with status\r\n          dbPromise.then(async db => {\r\n            const tx = db.transaction('storeInfo', 'readwrite');\r\n            const store = tx.objectStore('storeInfo');\r\n\r\n            const req = await store.get(cursor.value.restaurant_id);\r\n            const currStore = req;\r\n            currStore.is_favorite = cursor.value.is_favorite;\r\n            store.put(currStore, cursor.value.restaurant_id);\r\n          })\r\n        }\r\n\r\n        cursor.delete();\r\n        return cursor.continue().then(cycleItems);\r\n      })\r\n\r\n    // now check tempReviews - this will have offline reviews saved\r\n    dbPromise.then(function (db) {\r\n      const tx = db.transaction('tempReviews', 'readwrite');\r\n      const store = tx.objectStore('tempReviews');\r\n      return store.openCursor();\r\n    })\r\n      .then(function cycleReviews(cursor) {\r\n        if (!cursor) return;\r\n\r\n        if (cursor.value.type === 'review') {\r\n          // add new reviews\r\n          // set up review as requested in server options - will remove type key\r\n          const review = {\r\n            \"restaurant_id\": cursor.value.restaurant_id,\r\n            \"name\": cursor.value.name,\r\n            \"rating\": parseInt(cursor.value.rating, 10),\r\n            \"comments\": cursor.value.comments\r\n          }\r\n          // post to server and add to reviews db\r\n          fetch('http://localhost:1337/reviews/', {\r\n            method: 'POST',\r\n            body: JSON.stringify(review)\r\n          })\r\n          dbPromise.then(async db => {\r\n            const tx = db.transaction('reviews', 'readwrite');\r\n            const store = tx.objectStore('reviews');\r\n            console.log('adding an offline stashed review to the db');\r\n            store.add(review);\r\n          });\r\n        }\r\n      })\r\n      */\r\n  }\r\n\r\n} //end of class\r\n","let restaurants,\r\n  neighborhoods,\r\n  cuisines\r\nvar newMap\r\nvar markers = []\r\n\r\n/**\r\n * Fetch neighborhoods and cuisines as soon as the page is loaded.\r\n */\r\ndocument.addEventListener('DOMContentLoaded', (event) => {\r\n  if (navigator.onLine) {\r\n    DBHelper.updateServer();\r\n  }\r\n  initMap(); \r\n  fetchNeighborhoods();\r\n  fetchCuisines();\r\n});\r\n\r\n/**\r\n * Fetch all neighborhoods and set their HTML.\r\n */\r\nfetchNeighborhoods = () => {\r\n  DBHelper.fetchNeighborhoods((error, neighborhoods) => {\r\n    if (error) { // Got an error\r\n      console.error(error);\r\n    } else {\r\n      self.neighborhoods = neighborhoods;\r\n      fillNeighborhoodsHTML();\r\n    }\r\n  });\r\n}\r\n\r\n/**\r\n * Set neighborhoods HTML.\r\n */\r\nfillNeighborhoodsHTML = (neighborhoods = self.neighborhoods) => {\r\n  const select = document.getElementById('neighborhoods-select');\r\n  neighborhoods.forEach(neighborhood => {\r\n    const option = document.createElement('option');\r\n    option.innerHTML = neighborhood;\r\n    option.value = neighborhood;\r\n    select.append(option);\r\n  });\r\n}\r\n\r\n/**\r\n * Fetch all cuisines and set their HTML.\r\n */\r\nfetchCuisines = () => {\r\n  DBHelper.fetchCuisines((error, cuisines) => {\r\n    if (error) { // Got an error!\r\n      console.error(error);\r\n    } else {\r\n      self.cuisines = cuisines;\r\n      fillCuisinesHTML();\r\n    }\r\n  });\r\n}\r\n\r\n/**\r\n * Set cuisines HTML.\r\n */\r\nfillCuisinesHTML = (cuisines = self.cuisines) => {\r\n  const select = document.getElementById('cuisines-select');\r\n\r\n  cuisines.forEach(cuisine => {\r\n    const option = document.createElement('option');\r\n    option.innerHTML = cuisine;\r\n    option.value = cuisine;\r\n    select.append(option);\r\n  });\r\n}\r\n\r\n/**\r\n * Initialize leaflet map, called from HTML.\r\n */\r\ninitMap = () => {\r\n  self.newMap = L.map('map', {\r\n    center: [40.722216, -73.987501],\r\n    zoom: 12,\r\n    scrollWheelZoom: false\r\n  });\r\n  L.tileLayer('https://api.tiles.mapbox.com/v4/{id}/{z}/{x}/{y}.jpg70?access_token={mapboxToken}', {\r\n    mapboxToken: 'pk.eyJ1IjoibGluZGFrdDE2IiwiYSI6ImNqaW1sY3Z4bjAxa2EzcHBmaTZ4aTE2dzQifQ.cOXPk5Jme5zrFsUP3KEgLw',\r\n    maxZoom: 18,\r\n    attribution: 'Map data &copy; <a href=\"https://www.openstreetmap.org/\">OpenStreetMap</a> contributors, ' +\r\n      '<a href=\"https://creativecommons.org/licenses/by-sa/2.0/\">CC-BY-SA</a>, ' +\r\n      'Imagery © <a href=\"https://www.mapbox.com/\">Mapbox</a>',\r\n    id: 'mapbox.streets'\r\n  }).addTo(newMap);\r\n\r\n  updateRestaurants();\r\n}\r\n\r\n/**\r\n * Update page and map for current restaurants.\r\n */\r\nupdateRestaurants = () => {\r\n  const cSelect = document.getElementById('cuisines-select');\r\n  const nSelect = document.getElementById('neighborhoods-select');\r\n\r\n  const cIndex = cSelect.selectedIndex;\r\n  const nIndex = nSelect.selectedIndex;\r\n\r\n  const cuisine = cSelect[cIndex].value;\r\n  const neighborhood = nSelect[nIndex].value;\r\n\r\n  DBHelper.fetchRestaurantByCuisineAndNeighborhood(cuisine, neighborhood, (error, restaurants) => {\r\n    if (error) { // Got an error!\r\n      console.error(error);\r\n    } else {\r\n      resetRestaurants(restaurants);\r\n      fillRestaurantsHTML();\r\n    }\r\n  })\r\n}\r\n\r\n/**\r\n * Clear current restaurants, their HTML and remove their map markers.\r\n */\r\nresetRestaurants = (restaurants) => {\r\n  // Remove all restaurants\r\n  self.restaurants = [];\r\n  const ul = document.getElementById('restaurants-list');\r\n  ul.innerHTML = '';\r\n\r\n  // Remove all map markers\r\n  if (self.markers) {\r\n    self.markers.forEach(marker => marker.remove());\r\n  }\r\n  self.markers = [];\r\n  self.restaurants = restaurants;\r\n}\r\n\r\n/**\r\n * Create all restaurants HTML and add them to the webpage.\r\n */\r\nfillRestaurantsHTML = (restaurants = self.restaurants) => {\r\n  const ul = document.getElementById('restaurants-list');\r\n  restaurants.forEach(restaurant => {\r\n    ul.append(createRestaurantHTML(restaurant));\r\n    addMarkersToMap();\r\n  });\r\n};  \r\n\r\n/**\r\n * Create restaurant HTML.\r\n */\r\ncreateRestaurantHTML = (restaurant) => {\r\n  const li = document.createElement('li');\r\n\r\n  const image = document.createElement('img');\r\n  image.className = 'restaurant-img';\r\n  image.src = DBHelper.imageUrlForRestaurant(restaurant);\r\n  image.alt = `A photo showcasing the atmosphere of ${restaurant.name}`;\r\n  li.append(image);\r\n\r\n  const fav = document.createElement('button');\r\n  fav.className = ('favButton');\r\n  fav.setAttribute('aria-label', `Toggle this restaurant's favorite status`);\r\n  const favOn = document.createElement('img'); \r\n  favOn.src = `./img/icons/fav_on.svg`;\r\n  favOn.className = 'favorite on';\r\n  favOn.alt = 'Favorite restaurant toggle turned on';\r\n  const favOff = document.createElement('img');\r\n  favOff.src = `./img/icons/fav_off.svg`;\r\n  favOff.className = 'favorite off';\r\n  favOff.alt = 'Favorite restaurant toggle turned off';\r\n  if (restaurant.is_favorite == 'true') {\r\n    favOff.classList.add('hide');\r\n  }\r\n  if (restaurant.is_favorite == 'false') {\r\n  favOn.classList.add('hide');\r\n  } \r\n  fav.append(favOff, favOn);\r\n  li.append(fav);\r\n\r\n  const trigger = li.querySelector('.favButton');\r\n  \r\n  trigger.addEventListener('click', function(e) {\r\n    e.preventDefault();\r\n    DBHelper.toggleFav(trigger, restaurant.id);\r\n  })\r\n  \r\n  const name = document.createElement('h3');\r\n  name.innerHTML = restaurant.name;\r\n  li.append(name);\r\n\r\n  const neighborhood = document.createElement('p');\r\n  neighborhood.innerHTML = restaurant.neighborhood;\r\n  li.append(neighborhood);\r\n\r\n  const address = document.createElement('p');\r\n  address.innerHTML = restaurant.address;\r\n  li.append(address);\r\n\r\n  const more = document.createElement('a');\r\n  more.innerHTML = 'View Details';\r\n  more.setAttribute('aria-label', `View details for ${restaurant.name}`);\r\n  more.href = DBHelper.urlForRestaurant(restaurant);\r\n  li.append(more)\r\n\r\n  return li\r\n}\r\n\r\n/**\r\n * Add markers for current restaurants to the map.\r\n */\r\naddMarkersToMap = (restaurants = self.restaurants) => {\r\n  restaurants.forEach(restaurant => {\r\n    // Add marker to the map\r\n    const marker = DBHelper.mapMarkerForRestaurant(restaurant, self.newMap);\r\n    marker.on(\"click\", onClick);\r\n    function onClick() {\r\n      window.location.href = marker.options.url;\r\n    }\r\n    self.markers.push(marker);\r\n  });\r\n\r\n} \r\n\r\n"]}